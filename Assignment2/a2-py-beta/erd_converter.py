from erd import *
from table import *

# This function converts an ERD object into a Database object
# The Database object should correspond to a fully correct implementation
# of the ERD, including both data structure and constraints, such that the
# CREATE TABLE statements generated by the Database object will populate an
# empty MySQL database to exactly implement the conceptual design communicated
# by the ERD.
#
# @TODO: Implement me!
def convert_to_table(erd):
    entityTables = createEntityTables(erd)
    entityTables = createWeakTables(entityTables, erd)
    #entityTables = oneToOne(entityTables, erd)
    entityTables = oneToMany(entityTables, erd)
    manyToManyTables = manyToMany(erd)
    
    sample_db = Database(entityTables + manyToManyTables)
    return sample_db
"""
def oneToOne(entityTables, erd):

    tempList = []
    for i in erd.entity_sets:
        for j, elem1 in enumerate(i.connections):

            for l in erd.entity_sets:
                for k, elem2 in enumerate(l.connections):

                    if i.name != l.name:
                        if i.connections[j][1] == Multiplicity.ONE and l.connections[k][1] == Multiplicity.ONE and i.connections[j][0] == l.connections[k][0]:
                            for m in erd.relationships:
                                if m.name == i.connections[j][0] and m.primary_key != []:
                                    temp = [i.name, l.name]
                                    temp.sort()
                                    temp.append(m.name)
                                    if temp not in tempList:
                                        tempList.append(temp)
                                elif m.name == i.connections[j][0] and m.primary_key == []:
                                    temp = [i.name, l.name]
                                    temp.sort()
                                    if temp not in tempList:
                                        tempList.append(temp)

    if len(tempList) == 0:
        return entityTables

    for i in tempList:
        if len(i) == 2:
            #for i in tempList:
            for j in entityTables:
                if i[0] == j.name:
                     for l in entityTables:
                         if i[1] == l.name:
                             j.attributes.update(sorted(l.primary_key))
                             tempKeys = tuple(sorted(l.primary_key))
                             j.foreign_keys.update([(tempKeys, l.name, tempKeys)])
        elif len(i) == 3:
            for j in entityTables:
                if i[0] == j.name:
                     for l in entityTables:
                         if i[1] == l.name:
                             for z in erd.relationships:
                                 if z.name == i[2]:
                                     tempName = z.name
                                     tempPK = z.primary_key
                                     tempAtt = z.attributes
                                     tempFK = []
                                     tempPK.extend(list(j.primary_key))
                                     tempPK.extend(list(l.primary_key))
                                     tempAtt.extend(list(j.primary_key))
                                     tempAtt.extend(list(l.primary_key))
                                     tempFK.append(tuple((tuple(j.primary_key), j.name, tuple(j.primary_key))))
                                     tempFK.append(tuple((tuple(l.primary_key), l.name, tuple(l.primary_key))))
                                     entityTables.append(Table(tempName, set(sorted(tempAtt)), set(tempPK), set(tempFK)))

    return entityTables
"""

#for 1-to-M relationships, include the primary key of the side of the relationship that is on the 1 side, in the other entity, as a foreign key.
def oneToMany(entityTables, erd):

    tempList = []
    for i in erd.entity_sets:
        for j, elem1 in enumerate(i.connections):

            for l in erd.entity_sets:
                for k, elem2 in enumerate(l.connections):

                    if i.name != l.name:
                        if i.connections[j][1] == Multiplicity.MANY and l.connections[k][1] == Multiplicity.ONE and i.connections[j][0] == l.connections[k][0]:
                            added = 0
                            for m in erd.relationships:
                                if m.name == i.connections[j][0] and m.primary_key != []:
                                    temp = [i.name, l.name]
                                    temp.append(m.name)
                                    if temp not in tempList:
                                        tempList.append(temp)
                                        added = 1
                            if added == 1:
                                break
                            else:
                                for z in entityTables:
                                    if z.name == i.name:
                                        z.attributes.update(sorted(l.primary_key))
                                        tempKeys = tuple(sorted(l.primary_key))
                                        z.foreign_keys.update([(tempKeys, l.name, tempKeys)])

    for i in tempList:
        for j in entityTables:
            if i[0] == j.name:
                 for l in entityTables:
                     if i[1] == l.name:
                         for z in erd.relationships:
                             if z.name == i[2]:
                                 tempName = z.name
                                 tempPK = z.primary_key
                                 tempAtt = z.attributes
                                 tempFK = []
                                 tempPK.extend(list(j.primary_key))
                                 tempAtt.extend(list(j.primary_key))
                                 tempAtt.extend(list(l.primary_key))
                                 tempFK.append(tuple((tuple(j.primary_key), j.name, tuple(j.primary_key))))
                                 tempFK.append(tuple((tuple(l.primary_key), l.name, tuple(l.primary_key))))
                                 entityTables.append(Table(tempName, set(sorted(tempAtt)), set(tempPK), set(tempFK)))
    return entityTables

def manyToMany(erd):
    tempList = []
    for i in erd.entity_sets:
        for j, elem1 in enumerate(i.connections):

            for l in erd.entity_sets:
                for k, elem2 in enumerate(l.connections):

                    if i.name != l.name:
                        if i.connections[j][1] == Multiplicity.MANY and l.connections[k][1] == Multiplicity.MANY and i.connections[j][0] == l.connections[k][0]:
                            temp = sorted([i.name,l.name,i.connections[j][0]])
                            if temp not in tempList:
                                tempList.append([i.name,l.name,i.connections[j][0]])
                            else:
                                continue

    if len(tempList) == 0:
        return []

    tempTableList = []
    for i in tempList:
        tempName = ""
        tempPrimaryKeys = []
        tempAttr = []
        tempFK = []
        for j in erd.relationships:
            if i[2] == j.name:
                tempName = j.name
                if j.primary_key != []:
                    tempPrimaryKeys.extend(j.primary_key)
                    tempAttr.extend(j.primary_key)
                if j.attributes != []:
                    tempAttr.extend(j.attributes)
                for k in erd.entity_sets:
                    if k.name == i[0] or k.name == i[1]:
                        tempPrimaryKeys.extend(k.primary_key)
                        tempAttr.extend(k.primary_key)
                        tempFK.append(tuple((tuple(k.primary_key), k.name, tuple(k.primary_key))))
        tempFK.sort()
        tempTableList.append(Table(tempName, set(sorted(tempAttr)), set(sorted(tempPrimaryKeys)), set(tempFK)))

    return tempTableList

def createEntityTables(erd):
    tempTableList = []
    tableName = ""

    for i in erd.entity_sets:
        if i.supporting_relations != []:
            continue

        tableAttributes = []
        tablePrims = []
        tempFK = []
        tableName = i.name

        if i.parents != []:
            for j in i.parents:
                for l in erd.entity_sets:
                    if j == l.name:
                        tableAttributes.extend(l.primary_key)
                        tablePrims.extend(l.primary_key)
                        tempFK.append(tuple((tuple(l.primary_key), l.name, tuple(l.primary_key))))

        tableAttributes.extend(i.attributes)
        tablePrims.extend(i.primary_key)
        tempTable = Table(tableName, set(tableAttributes), set(tablePrims), set(tempFK))
        tempTableList.append(tempTable)

    return tempTableList

def createWeakTables(entityTables, erd):
    tempTableList = []
    tableName = ""

    for i in erd.entity_sets:
        if i.supporting_relations != []:
            tableAttributes = []
            tablePrims = []
            tempFK = []
            tableName = i.name

            tableAttributes.extend(i.attributes)
            tablePrims.extend(i.primary_key)

            for j in i.supporting_relations:
                for l in erd.entity_sets:
                    for k in l.connections:
                        if k[0] == j and l.name != i.name:
                            tablePrims.extend(l.primary_key)
                            tableAttributes.extend(l.primary_key)
                            tempFK.append(tuple((tuple(l.primary_key), l.name, tuple(l.primary_key))))

            tempFK.sort()
            tempTable = Table(tableName, set(tableAttributes), set(tablePrims), set(tempFK))
            tempTableList.append(tempTable)

    entityTables = entityTables + tempTableList

    for i in erd.entity_sets:
        if i.supporting_relations != []:
            tempFK = []
            tableName = i.name

            tableAttributes.extend(i.attributes)
            tablePrims.extend(i.primary_key)

            for j in i.supporting_relations:
                for l in erd.entity_sets:
                    for k in l.connections:
                        if k[0] == j and l.name != i.name:
                            for z in entityTables:
                                if z.name == l.name:
                                    for y in entityTables:
                                        if y.name == i.name:
                                            if len(z.primary_key - y.primary_key) != 0:
                                                temp = z.primary_key - y.primary_key
                                                for elm in temp:
                                                    for elm2 in list(z.foreign_keys):
                                                        if elm in elm2[0]:
                                                            y.primary_key.add(elm)
                                                            y.attributes.add(elm)
                                                            y.foreign_keys.add(elm2)

    return entityTables
